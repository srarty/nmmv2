% Neural Mass Model based on Jensen and Rit
%
% Options:
%   x - states or estimated states
%   P - [] or covariance of estimated states
%
function varargout = nmm(x,P,mode,params)
% Indexes
v_idx = [1 3];
z_idx = [2 4];
u_idx = 5;
alpha_idx = [6 7];

% the parameters
dt = params.dt;

e_0 = params.e0;
r = params.r;	% varsigma
v0 = params.v0; % Threshold

decay_e = params.decay_e; % inverse time constants (excitatory)
decay_i = params.decay_i; % (inhibitory)

alpha_ei = params.alpha_ei; % synaptic gains (excitatory)
alpha_ie = params.alpha_ie; % (inhibitory)

u = params.u;	% mean input firing rate.

c_constant = 100;
c1 = 1*c_constant;	% number of synapses
c2 = 0.25*c_constant;

% the states
% Scaling the states (?)
% scale = b*[2/v0, 1, 2/v0, 1]; % Divides by the inhibitory time constant
% x = x .* scale';

v_e = x(1); % Excitatory
z_e = x(2); % Derivative (excitatory)
v_i = x(3); % Inhibitory
z_i = x(4); % Derivative (inhibitory)
u = x(5); % External input
a_ei = x(6); % Synaptic strength (e to i)
a_ie = x(7); % Synaptic strength (i to e)

% Number of augmented states
xlen = length(x);

% the state covariance
if ~isempty(P)
    sigma_sq_e = P(1,1);  % excitatory
    sigma_sq_i = P(3,3);  % inhib
    
    cov_e_i = P(1,3);
    cov_i_e = P(3,1);
else
    sigma_sq_e = 0;  % excitatory
    sigma_sq_i = 0;  % inhib
    
    cov_e_i = 0;
    cov_i_e = 0;
end

% Linear component of model
A =     [1,              dt,         0,              0,          0,  0,  0; ...
    -decay_e^2*dt,  1-2*decay_e*dt,  0,              0,          0,  0,  0; ...
         0,              0,          1,              dt,         0,  0,  0; ...
         0,              0    -decay_i^2*dt,   1-2*decay_i*dt,   0,  0,  0; ...
         0,              0,          0,              0,          1,  0,  0; ...
         0,              0,          0,              0,          0,  1,  0; ...
         0,              0,          0,              0,          0,  0,  1];

% B Matrix (Augmented parameters)
B = zeros(xlen);
B(z_idx, z_idx) = dt .* diag([decay_e decay_i].*ones(size(z_idx)));

% C Matrix (Augmented) - Commented because it is implicit in E_gx
C = zeros(xlen);
C(4,1) = 1; % inhibitory -> excitatory
C(2,3) = 1; % excitatory -> inhibitory
C(2,u_idx) = 1; % input -> excitatory

phi = non_linear_sigmoid(C*x,v0,r);

% Sigmoid functions
f_e = non_linear_sigmoid(u - v_i, r, v0, sigma_sq_i); % 0.5*erf((u - v_i - v0) / (sqrt(2 * (r^2 + sigma_sq_i)))) + 0.5;    % 0.5*erf((u - v_i - v0) / (sqrt(2) * r)) + 0.5;	   % excitatory population firing rate
f_i = non_linear_sigmoid(  v_e,   r, v0, sigma_sq_e); % 0.5*erf((v_e - v0) / (sqrt(2 * (r^2 + sigma_sq_e)))) + 0.5;        % 0.5*erf((v_e - v0) / (sqrt(2) * r)) + 0.5;        % inhibitory population firing rate


%alpha(syn_index) = alpha_e*2*f_max*C1*dt / tau(syn_index);

alpha_i = a_ei * c1 * 2 * e_0 *dt * decay_e; % lumped constant (inhibitory, input to)
alpha_e = a_ie * c2 * 2 * e_0; % lumped constant (excitatory, input to)

x(6) = alpha_e;
x(7) = alpha_i;

switch mode
    case 'transition'
        % Nonlinear component
        gx = [0; ...
            alpha_e*f_i; ...
            0; ...
            alpha_i*f_e;...
            0; ...
            0; ...
            0];
                
        % Nonlinear transition model
        varargout{1} = A*x + gx;
%         varargout{2} = A*P*A';
        
    case 'analytic'
        % the expectation and covariance of a Gaussian distribution
        % transformed by the NMM        
        % E[Fx + g(x)] = F*E[x] + E[g(x)]
        
        % expectations for inhibitory and excitatory firing rates
        % these erf inputs get re-used (boilerplate)
        %{
        input_i = (u - v_i - v0) / (sqrt(2 * (r^2 + sigma_sq_i)));
        input_e = (v_e - v0) / (sqrt(2 * (r^2 + sigma_sq_e)));
                
        e_gi = 0.5*erf(input_i) + 0.5;     % inhibitory population firing rate g(x_i)
        e_ge = 0.5*erf(input_e) + 0.5;     % excitatory population firing rate g(x_e)
        %}
        
        % Nonlinear component of expectation
        % E[g(x)] is E_gx, or E[phi(E)]
        E_gx = [0; ...
                alpha_e*f_i; ...
                0; ...
                alpha_i*f_e;...
                0; ...
                0; ...
                0];
                        
        % Analytic mean
        analytic_mean = A*x + B*x.*phi; % Matrices B and C are implicit in E_gx
        
        % Analytic covariance
        %% P1 = APA'
        P1 = A*P*A'; % P2 = Q; % Q is added in analytic_kalman_filter_2 after calling nmm function
        
        %% P3 = -E[phi(E)]E[phi(E)'], this is, E[E_phi(E)] = E_gx 
        P3 = -E_gx*E_gx';
        
        %% P4 = -A*E_hat*E[phi(E)'] 
        P4 = -A*x*E_gx';
        
        %% P5 = -E[phi(E)](A*E_hat)' 
        P5 = -E_gx*(A*x)';
        
        %% P6 = E[phi(E)phi(E)'] 
        P6 =  E_gx_gx(x, P, u, v0, r, false); % All the values of P (for all the states) % Do I need the dt? % This is E_gx_gx or E[g(x)g(x)] equation 25 to 30 SKF_Derivation_Prob
                
        %% P7 and P8 
        % Question: Do this term need to be multiplied by dt?         
        E_x_gx = [0                     0                          0                           0                    0  0  0; ...
                  0                     0                          0        E_xi_gxj(x(1),x(3),v0,P(3,3), P(1,3),r) 0  0  0; ...
                  0                     0                          0                           0                    0  0  0; ...
                  0    E_xi_gxj(x(3),x(1),v0,P(1,1), P(3,1),r)     0                           0                    0  0  0; ...
                  0                     0                          0                           0                    0  0  0; ...
                  0                     0                          0                           0                    0  0  0; ...
                  0                     0                          0                           0                    0  0  0];
        
        %{
        E_x_gx = zeros(size(x,1));
        for i = 1:size(x,1)
            for j = 1:size(x,1)
                E_x_gx(i,j) = E_xi_gxj(x(i),x(j),v0,P(j,j), P(i,j),r);
            end
        end
        %}
                  
        P7 = E_x_gx;% F*E_x_gx_1'; % This is E_x_gx = E[x_e *  g(x_i)] and E[x_i *  g(x_e)]? equation 22 SKF_Derivation_Prob
                
        P8 = E_x_gx';% E_gx_x;% E_x_gx_2*F'; % This is the transpose of P7
        
        %% Output:
        % TODO: Fix P3, 4 and 5. Their order of magnitude is too large?
        % TODO: Deactivate each term once at a time to find out which one 
        % TODO: double check the dropped term in propagate mean and variance
        % TODO: Check the 1's and 0's are correctly placed in Egxgx

        analytic_cov = P1 + P3 + P4 + P5 + P6 + P7 + P8;            
%         analytic_cov = P1 ;%+ 1e-2*(P3 + P4 + P5) + P6 + P7 + P8;   
%         analytic_cov = P1 + 1e-2*(P3 + P4 + P5 + P6 + P7 + P8);
        
        varargout{1} = analytic_mean; % E_t
        varargout{2} = analytic_cov; % P_t
        
    case 'jacobian'        
        % Linearise g()
        f_i_derivative = 2*e_0*r*f_i*(1-f_i);      % inhibitory feedback firing
        f_e_derivative = 2*e_0*r*f_e*(1-f_e);      % excitatory feedback firing
        
        G = [   0,                  0,              0,                      0,	0,  0,  0; ...
                0,                  0,  -dt*alpha_ie*decay_i*c2*f_i_derivative,   0,	0,  0,  0; ...
                0,                  0,              0,                      0,	0,  0,  0; ...
  dt*alpha_ei*decay_e*c1*f_e_derivative,  0,              0,                      0,	0,  0,  0; ...
                0,                  0,              0,                      0,  0,  0,  0; ...
                0,                  0,              0,                      0,  0,  0,  0; ...
                0,                  0,              0,                      0,  0,  0,  0];
        
        % Jacobian
        varargout{1} = A + G;
end % End switch

% Optional outputs
varargout{3} = f_i;
varargout{4} = f_e;

end % End function model_NM_augmented

%% Function to calculate P6
function expectation = E_gx_gx(x, P, u, v0, r, montecarlo, varargin)
    % Computes the 6th term of the analytic covariance polynomial
    % Inputs:
    %   montecarlo - If 'true', it calculates it in a montecarlo
    %   N (varargin) - number of montecarlo iterations
    if montecarlo
        if nargin > 5
            N = varargin{1};
        else
            N = 50;
        end
        %tic
        % out_ = zeros(size(x,1),size(x,1), N);  % All the values of P (for all the states)
        out_ = zeros(size(x,1)/2,size(x,1)/2, N); % Only the values of P that correspond to membrane potential
        for nn = 1:N
            % MV gaussian
            % x_ = mvnrnd(x, P, 5000); % All the values of P (for all the states)
            x_ = mvnrnd(x([1 3],:), P([1 3], [1 3], :), 5000); % Only the values of P that correspond to membrane potential
            out = non_linear_sigmoid(x_, r, v0); % out = non_linear_sigmoid([v_e z_e v_i z_i], r, v0);
            out = mean(out);
            % Matrix multiplication
            out_(:,:,nn) = out' * out;
            
            % Manually compute phi(x)*phi(x)' (considering x is a column vector)
            %             out_(2,2,nn) = out(:,1).*out(:,1);
            %             out_(4,4,nn) = out(:,2).*out(:,2);
            %             out_(2,4,nn) = out(:,1).*out(:,2);
            %             out_(4,2,nn) = out(:,2).*out(:,1);
        end
        Egxgx = mean(out_,3);
        expectation = zeros(size(P));
        expectation([2,4],[2,4]) = Egxgx; % Only the values of P that correspond to membrane potential
        %toc
    else
        % If montecarlo is 'false', calculate the expectation analytically
        % State covariance
        if ~isempty(P)
            sigma_sq_e = P(1,1);  % excitatory
            sigma_sq_i = P(3,3);  % inhib
            cov_e_i = P(1,3);
            cov_i_e = P(3,1);
        else
            sigma_sq_e = 0;  % excitatory
            sigma_sq_i = 0;  % inhib
            cov_e_i = 0;
            cov_i_e = 0;
        end
        % States (membrane potentials)
        v_e = x(1); % Excitatory
        v_i = x(3); % Inhibitory
        
        z_ = v0 + r.*randn(1,2); % Two new independent variables
        z = 0.5*erf((z_ - v0) ./ sqrt(2 * (r^2 + [sigma_sq_e sigma_sq_i].^2))) + 0.5; % Non linear function        
        mu_hat = [v0 - v_e + u, v0 - v_i];               
        
        sigma_hat = [r^2+sigma_sq_e, cov_e_i; ...
                     cov_i_e       , r^2+sigma_sq_i];  
                
        expectation = mvncdf(z, mu_hat, sigma_hat); % Multivariate Gaussian cumulative distribution 
    end
end

%% Function to calculate P7 and P8
function expectation = E_xi_gxj(x_i,x_j, v0, s_jj, s_ij, r)
% Computes the 7th and 8th terms of the P polynomial (P7 and P8). Equation
% 29 from SKF_Derivation_Algebraic:
% E[f(x)] = (x_i/2)*erf((x_j-v0)/sqrt(2(s_jj + r^2))) + x_i/2 + s_ij/sqrt(2*pi*(s_jj + r^2))*exp(-(x_j-v0)^2/(2*(s_jj+r^2)))

expectation = (x_i/2)*erf((x_j-v0)/sqrt(2*(s_jj + r^2))) + x_i/2 +...
    s_ij/sqrt(2*pi*(s_jj + r^2))*exp(-(x_j-v0)^2/(2*(s_jj+r^2)));

end

